use std::{borrow::Cow, cell::RefCell, rc::Rc};

use super::error::EvalError;
use crate::parser::traits::lox_callable::LoxCallable;
use crate::{interpreter::Environment, tokenizer::token::Token};

pub type ValueResult = Result<Value, EvalError>;
/// A value generated by evaluating a Lox expression
#[derive(Debug, Default, PartialEq, Clone)]
pub enum Value {
    /// Any value that can be used in a function call
    /// Think of () as a postfix operator, then the justification for including a Function in Lox value makes sense
    /// `LoxVal()`.eval() -> Another `LoxVal2` which may be another function and evaluated as `LoxVal2`.eval() -> LoxVal3
    Function(LoxFunction),
    Break,
    Double(f64),
    Bool(bool),
    String(String),
    #[default]
    Nil,
}
impl Value {
    pub fn is_numeric(&self) -> Option<f64> {
        match self {
            Value::Double(d) => Some(*d),
            _ => None,
        }
    }
    pub fn is_string<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Value::String(s) => Some(Cow::Borrowed(s)),
            _ => None,
        }
    }
    pub fn is_equal(&self, other: &Value) -> bool {
        self == other
    }
    /// Only false, and nil are falsey, rest everything else is truthy
    pub fn is_truthy(&self) -> bool {
        match self {
            Value::Bool(b) => *b,
            Value::Nil => false,
            _ => true,
        }
    }
}
impl std::cmp::PartialOrd for Value {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use std::cmp::Ordering::*;
        match (self.is_numeric(), other.is_numeric()) {
            (Some(l), Some(r)) => l.partial_cmp(&r),
            _ => match (&self, &other) {
                (Value::Bool(l), Value::Bool(r)) => l.partial_cmp(&r),
                (Value::String(l), Value::String(r)) => l.partial_cmp(&r),
                (Value::Nil, Value::Bool(_)) => None, // We disallow nil to be compared against booleans, may change if needed
                (Value::Nil, Value::Nil) => Some(Equal),
                _ => None,
            },
        }
    }
}
impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Value::Double(x) => write!(f, "{x}"),
            Value::Bool(x) => write!(f, "{x}"),
            Value::String(x) => write!(f, "\"{x}\""),
            Value::Nil => write!(f, "Nil"),
            Value::Break => write!(f, "BreakValue"),
            Value::Function(_) => todo!(),
        }
    }
}
impl From<bool> for Value {
    fn from(b: bool) -> Self {
        Self::Bool(b)
    }
}
impl From<String> for Value {
    fn from(x: String) -> Self {
        Self::String(x)
    }
}
impl From<f64> for Value {
    fn from(f: f64) -> Self {
        Self::Double(f)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct LoxFunction {
    pub stack_env: Rc<RefCell<Environment>>,
    /// Let's just consider every function to be identified by a token
    pub ident: Token,
}
/// Since LoxFunction is a special value that can be called, we express that through this trait
impl LoxCallable for LoxFunction {
    type Environment = Rc<RefCell<Environment>>;
    fn call(&self, args: Vec<Value>, env: &Self::Environment) -> ValueResult {
        // TODO: implement this
        Ok(Value::Nil)
    }
}
