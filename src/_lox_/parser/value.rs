use std::borrow::Cow;
/// A value generated by evaluating a Lox expression
#[derive(Debug, Default, PartialEq)]
pub enum Value {
    Double(f64),
    Bool(bool),
    String(String),
    #[default]
    Nil,
}
impl Value {
    pub fn is_numeric(&self) -> Option<f64> {
        match self {
            Value::Double(d) => Some(*d),
            _ => None,
        }
    }
    pub fn is_string<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Value::String(s) => Some(Cow::Borrowed(s)),
            _ => None,
        }
    }
    pub fn is_equal(&self, other: &Value) -> bool {
        self == other
    }
    /// Only false, and nil are falsey, rest everything else is truthy
    pub fn is_truthy(&self) -> bool {
        match self {
            Value::Bool(b) => *b,
            Value::Nil => false,
            _ => true,
        }
    }
}
impl std::cmp::PartialOrd for Value {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        match (self.is_numeric(), other.is_numeric()) {
            (Some(l), Some(r)) => l.partial_cmp(&r),
            _ => None,
        }
    }
}

impl From<bool> for Value {
    fn from(b: bool) -> Self {
        Self::Bool(b)
    }
}
impl From<String> for Value {
    fn from(x: String) -> Self {
        Self::String(x)
    }
}
impl From<f64> for Value {
    fn from(f: f64) -> Self {
        Self::Double(f)
    }
}
