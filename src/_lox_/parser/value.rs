use std::{borrow::Cow, cell::RefCell, rc::Rc};

use super::error::EvalError;
use super::statement::Stmt;
use crate::interpreter::{self, Environment, Interpreter, Memory};
use crate::parser::traits::lox_callable::LoxCallable;
use crate::tokenizer::token::Token;
type LoxEnvironment = Rc<RefCell<Environment>>;
pub type ValueResult = Result<Value, EvalError>;
/// A value generated by evaluating a Lox expression
#[derive(Debug, Default, Clone)]
pub enum Value {
    /// Any value that can be used in a function call
    /// Think of () as a postfix operator, then the justification for including a Function in Lox value makes sense
    /// `LoxVal()`.eval() -> Another `LoxVal2` which may be another function and evaluated as `LoxVal2`.eval() -> LoxVal3
    Function(Rc<dyn LoxCallable>),
    Break,
    Double(f64),
    Bool(bool),
    String(String),
    #[default]
    Nil,
}
impl Value {
    pub fn is_numeric(&self) -> Option<f64> {
        match self {
            Value::Double(d) => Some(*d),
            _ => None,
        }
    }
    pub fn is_string<'a>(&'a self) -> Option<Cow<'a, str>> {
        match self {
            Value::String(s) => Some(Cow::Borrowed(s)),
            _ => None,
        }
    }
    pub fn is_equal(&self, other: &Value) -> bool {
        self == other
    }
    /// Only false, and nil are falsey, rest everything else is truthy
    pub fn is_truthy(&self) -> bool {
        match self {
            Value::Bool(b) => *b,
            Value::Nil => false,
            _ => true,
        }
    }
}
impl PartialEq for Value {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::Function(l0), Self::Function(r0)) => {
                let l = &*l0 as &dyn std::any::Any;
                let r = &*r0 as &dyn std::any::Any;
                match (
                    l.downcast_ref::<LoxFunction>(),
                    r.downcast_ref::<LoxFunction>(),
                ) {
                    (Some(l1), Some(l2)) => l1 == l2,
                    (_, _) => false,
                }
            }
            (Self::Double(l0), Self::Double(r0)) => l0 == r0,
            (Self::Bool(l0), Self::Bool(r0)) => l0 == r0,
            (Self::String(l0), Self::String(r0)) => l0 == r0,
            _ => core::mem::discriminant(self) == core::mem::discriminant(other),
        }
    }
}
impl std::cmp::PartialOrd for Value {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use std::cmp::Ordering::*;
        match (self.is_numeric(), other.is_numeric()) {
            (Some(l), Some(r)) => l.partial_cmp(&r),
            _ => match (&self, &other) {
                (Value::Bool(l), Value::Bool(r)) => l.partial_cmp(&r),
                (Value::String(l), Value::String(r)) => l.partial_cmp(&r),
                (Value::Nil, Value::Bool(_)) => None, // We disallow nil to be compared against booleans, may change if needed
                (Value::Nil, Value::Nil) => Some(Equal),
                _ => None,
            },
        }
    }
}
impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Value::Double(x) => write!(f, "{x}"),
            Value::Bool(x) => write!(f, "{x}"),
            Value::String(x) => write!(f, "\"{x}\""),
            Value::Nil => write!(f, "Nil"),
            Value::Break => write!(f, "BreakValue"),
            Value::Function(_) => todo!(),
        }
    }
}
impl From<bool> for Value {
    fn from(b: bool) -> Self {
        Self::Bool(b)
    }
}
impl From<String> for Value {
    fn from(x: String) -> Self {
        Self::String(x)
    }
}
impl From<f64> for Value {
    fn from(f: f64) -> Self {
        Self::Double(f)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct LoxFunction {
    /// Environment in which to execute function body
    pub stack_env: Rc<RefCell<Environment>>,
    /// Let's just consider every function to be identified by a token
    pub ident: Token,
    pub arity: usize,
    /// Always constructed to be a Stmt::Block
    pub body: Box<Stmt>,
    /// We need this as HashMaps don't preserve order in keys and we need
    /// order to figure out correct instantiation of variables
    pub params : Vec<String>,
}

/// Since LoxFunction is a special value that can be called, we express that through this trait
impl LoxCallable for LoxFunction {
    fn call(&self, args: Vec<Value>, interpreter: &mut Interpreter) -> ValueResult {
        // println!("FUnction BoDy -> {}", self.body);
        if args.len() != self.params.len() {
            return Err(EvalError::ArityMismatch(self.params.len(), args.len()));
        }
        // let stack_env = self.stack_env.borrow_mut();
        for (name, value) in self.params.iter().zip(args.into_iter()) {
            self.stack_env.put(name, value);
        }
        interpreter.execute(&self.body, Rc::clone(&self.stack_env), false)
    }
    fn arity(&self) -> usize {
        self.arity
    }
}
